( ) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------

>> 16:10 02/01/2025 RB - VNC-HOURS/Área_de_Desenvolvimento/--Historic_Code--/VNC_horario_sab.py
- [ ] INSERIR FUNÇÃO PARA EXIBIR DETALHES DAS LINHAS PERIÓDICAMENTE

de (linha 54)
        Vazio

para (linha 54)
        # Variável de controle para alternar exibição
        self.toggle_display = True
        self.current_line_index = 0

de (linha 82)

        # Verificar se há horários disponíveis
        if not horarios_filtrados:
            schedule_text = 'Nenhum horário disponível'
            self.schedule_label.configure(text=schedule_text)
        else:
            # Atualizar o rótulo com a data atual
            schedule_text = 'VILA NOVA CACHOEIRINHA | ' + datetime.datetime.now().strftime('%d/%m/%Y')
            self.schedule_label.configure(text=schedule_text)

            # Limpar a tabela antes de atualizar
            self.treeview.delete(*self.treeview.get_children())

            # Adicionar os horários filtrados na tabela
            for h in horarios_filtrados:
                parada = h.get('PARADA', '-')
                partida = datetime.datetime.strptime(h.get('PARTIDA', '').strip(), '%H:%M').strftime('%H:%M')
                linha = h.get('LINHA', '-')
                destino = h.get('DESTINO', '-')
                self.treeview.insert("", "end", values=(parada, partida, linha, destino))

        # Agendar a próxima atualização em 60 segundos
        self.master.after(1000, self.update_schedule)

    def update_clock(self):
        current_time = datetime.datetime.now().strftime('%d/%m/%Y \ %H:%M:%S')

para (linha 82)
        # Agrupar horários por linha
        linhas_grupo = {}
        for h in horarios_filtrados:
            linha = h.get('LINHA', '-')
            if linha not in linhas_grupo:
                linhas_grupo[linha] = []
            linhas_grupo[linha].append(h)

        if horarios_filtrados:
            # Alternar entre exibição de todas as linhas e linha isolada
            if self.toggle_display:
                # Exibir todas as linhas juntas
                self.treeview.delete(*self.treeview.get_children())
                for h in horarios_filtrados:
                    parada = h.get('PARADA', '-')
                    partida = datetime.datetime.strptime(h.get('PARTIDA', '').strip(), '%H:%M').strftime('%H:%M')
                    linha = h.get('LINHA', '-')
                    destino = h.get('DESTINO', '-')
                    self.treeview.insert("", "end", values=(parada, partida, linha, destino))
            else:
                # Exibir todas as próximas partidas da linha isolada
                self.treeview.delete(*self.treeview.get_children())
                linha_atual = list(linhas_grupo.keys())[self.current_line_index]  # Selecionar a linha atual
                for h in linhas_grupo[linha_atual]:
                    parada = h.get('PARADA', '-')
                    partida = datetime.datetime.strptime(h.get('PARTIDA', '').strip(), '%H:%M').strftime('%H:%M')
                    linha_texto = h.get('LINHA', '-')
                    destino = h.get('DESTINO', '-')
                    self.treeview.insert("", "end", values=(parada, partida, linha_texto, destino))

                # Avançar para a próxima linha
                self.current_line_index = (self.current_line_index + 1) % len(linhas_grupo)

            # Alternar o estado da exibição
            self.toggle_display = not self.toggle_display

        else:
            # Se não houver horários futuros, limpar a tabela
            self.treeview.delete(*self.treeview.get_children())

        # Agendar a próxima atualização em 20 segundos
        self.master.after(20000, self.update_schedule)

    def update_clock(self):
        current_time = datetime.datetime.now().strftime('%d/%m/%Y - %H:%M:%S')

(X) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------
>> 00:46 27/12/2024 RB - VNC-hours/Área_de_Desenvolvimento/--Historic_Code--/VNC_horario_sab.py
AJUSTAR JANELA PARA UTILIZAR A BIBLIOTECA CUSTOMTKINTER

de (linha 4)
import tkinter as tk

para (linha 4)
import customtkinter as ctk

de (linha 22)
        master.configure(bg='#000000')
        
        # Define o estilo da tabela
        style = ttk.Style()
        style.theme_use('default')
        
        style.configure('Treeview.Heading', background='#000000', foreground='#FFFFFF', rowheight=45, fieldbackground='#FFFFFF', font=('Arial', 30, 'bold'))
        style.configure('Treeview', background='#333333', foreground='#FFFFFF', rowheight=70, fieldbackground='#F3F3F3', font=('Arial', 30))
        style.map('Treeview', background=[('selected', '#333333')])

para (linha 22)
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("dark-blue")

de (linha 33)
        self.schedule_label = tk.Label(master, text='', font=('Arial', 35, 'bold'), bg='#000000', fg='#F8F8F8')

para (linha 33)
        self.schedule_label = ctk.CTkLabel(master, text='', font=ctk.CTkFont(size=50, weight="bold"))

de (linha 36)
        # Criação da tabela para exibir os horários
        columns = ('PARADA', 'PARTIDA', 'LINHA', 'DESTINO')
        self.treeview = ttk.Treeview(master, columns=columns, show='headings')
        for col in columns:
            if col == 'PARADA':
                self.treeview.column("PARADA", width=210, minwidth=50, anchor='center')
                self.treeview.heading("PARADA", text="PARADA")
            if col == 'PARTIDA':
                self.treeview.column("PARTIDA", width=210, minwidth=50, anchor='center')
                self.treeview.heading("PARTIDA", text="PARTIDA")
            if col == 'LINHA':
                self.treeview.column("LINHA", width=210, minwidth=50, anchor='center')
                self.treeview.heading("LINHA", text="LINHA")
            if col == 'DESTINO':
                self.treeview.column("DESTINO", width=800, minwidth=50, anchor='w')
                self.treeview.heading("DESTINO", text="DESTINO")

        self.treeview.pack(pady=10)
    
        # Loop de atualização dos horários

para (linha 36)
        # Criação do frame da tabela
        self.table_frame = ctk.CTkFrame(master)
        self.table_frame.pack(fill="both", expand=True, padx=20, pady=20)

        style = ttk.Style() 
        style.configure("Treeview", font=('Arial', 35), rowheight=80, background="#333333", foreground="#FFFFFF") # Fontes maiores e linhas mais altas 
        style.configure("Treeview.Heading", font=('Arial', 40, 'bold'), background="#444444")

        # Criação do widget Treeview
        columns = ('PARADA', 'PARTIDA', 'LINHA', 'DESTINO')
        self.treeview = ttk.Treeview(self.table_frame, columns=columns, show='headings', height=15)

        for col in columns:
            self.treeview.heading(col, text=col)
            if col == 'PARADA':
                self.treeview.column("PARADA", width=210, anchor='center')
            elif col == 'PARTIDA':
                self.treeview.column("PARTIDA", width=210, anchor='center')
            elif col == 'LINHA':
                self.treeview.column("LINHA", width=210, anchor='center')
            elif col == 'DESTINO':
                self.treeview.column("DESTINO", width=800, anchor='w')

        self.treeview.pack(fill="both", expand=True)

de (linha 68)
        hora_atual = datetime.datetime.now().time()
        horarios_filtrados = []
        for h in horarios:
            partida_str = h.get('PARTIDA', '')
            if partida_str:
                partida = datetime.datetime.strptime(partida_str, '%H:%M').time()
                if partida > hora_atual:
                    horarios_filtrados.append(h)

        # Verificar se há horários disponíveis
        if not horarios_filtrados:
            schedule_text = 'Nenhum horário disponível'
        else:
            # Atualizar o rótulo com os horários filtrados
            schedule_text = 'VILA NOVA CACHOEIRINHA | ' + datetime.datetime.now().strftime('%d/%m/%Y \ %H:%M:%S')
            self.schedule_label.config(text=schedule_text)

            # Limpar a tabela
            self.treeview.delete(*self.treeview.get_children())

            # Exibir os horários filtrados na tabela
            for h in horarios_filtrados:
                parada = h.get('PARADA', '-')
                partida = datetime.datetime.strptime(h.get('PARTIDA', ''), '%H:%M').time()
                linha = h.get('LINHA', '')
                destino = h.get('DESTINO', '')
                if partida > hora_atual:
                    self.treeview.insert("", tk.END, values=(parada, partida, linha, destino), tags=("red",))
                else:
                    self.treeview.insert("", tk.END, values=(parada, partida, linha, destino))

        # Agendar a próxima atualização
        self.master.after(1000, self.update_schedule)  # 1000 milissegundos = 1 segundo

    def close_program(self, event):
        print("Programa finalizado pelo usuário.")
        self.master.destroy()

# Criação da janela principal e execução do loop de eventos do Tkinter
root = tk.Tk()

para (linha 68)
        # Hora atual
        hora_atual = datetime.datetime.now().time()

        # Filtrar os horários que ainda vão acontecer
        horarios_filtrados = []
        for h in horarios:
            partida_str = h.get('PARTIDA', '').strip()
            if partida_str:
                try:
                    # Converter o horário de partida para objeto datetime.time
                    partida = datetime.datetime.strptime(partida_str, '%H:%M').time()
                    if partida > hora_atual:
                        horarios_filtrados.append(h)
                except ValueError:
                    print(f"Erro ao converter horário: {partida_str}")

        # Verificar se há horários disponíveis
        if not horarios_filtrados:
            schedule_text = 'Nenhum horário disponível'
            self.schedule_label.configure(text=schedule_text)
        else:
            # Atualizar o rótulo com a data atual
            schedule_text = 'VILA NOVA CACHOEIRINHA | ' + datetime.datetime.now().strftime('%d/%m/%Y')
            self.schedule_label.configure(text=schedule_text)

            # Limpar a tabela antes de atualizar
            self.treeview.delete(*self.treeview.get_children())

            # Adicionar os horários filtrados na tabela
            for h in horarios_filtrados:
                parada = h.get('PARADA', '-')
                partida = datetime.datetime.strptime(h.get('PARTIDA', '').strip(), '%H:%M').strftime('%H:%M')
                linha = h.get('LINHA', '-')
                destino = h.get('DESTINO', '-')
                self.treeview.insert("", "end", values=(parada, partida, linha, destino))

        # Agendar a próxima atualização em 60 segundos
        self.master.after(1000, self.update_schedule)

    def update_clock(self):
        current_time = datetime.datetime.now().strftime('%d/%m/%Y \ %H:%M:%S')
        self.schedule_label.configure(text=f"VILA NOVA CACHOEIRINHA | {current_time}")
        self.master.after(1000, self.update_clock)  # Atualiza o relógio a cada segundo

    def close_program(self, event):
        print("Programa finalizado pelo usuário.")
        self.master.destroy()

# Criação da janela principal e execução do loop de eventos do customtkinter
root = ctk.CTk()

(X) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO

---------------------------------------------------------------------------------------------------------------

>> 23:35 04/11/2024 RB - VNC-hours/Área_de_Desenvolvimento/--Historic_Code--/VNC_horario_sab.py
INCREMENTAR LOG.TXT

de (linha 1)
caminho = ('VNC_horario_sab.CSV')

para (linha 1)
import os

de (linha 6)
Vazio

para (linha 6)
import sys

# Caminho para o log
log_path = 'log.txt'

# Redireciona a saída padrão para o arquivo log.txt
sys.stdout = open(log_path, 'a')  # Abre em modo append para adicionar ao log

caminho = 'VNC_horario_sab.csv'

de (linha 103)
Vazio

para (linha 103)
        print("Programa finalizado pelo usuário.")

de (linha 111)
Vazio

para (linha 111)
# Fecha o arquivo de log ao final da execução
sys.stdout.close()

(X) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------

>> 15:55 24/10/2024 RB - VNC-hours/Área_de_Desenvolvimento/--Historic_Code--/VNC_horario_sab.py
AO PRESSIONAR O BOTÃO "ESC", FECHAR A APLICAÇÃO

de (linha 50)
Vazio

para (linha 50)
        self.master.bind("<Escape>", self.close_program)

de (linha 93)
Vazio

para (linha 93)
    def close_program(self, event):
        self.master.destroy()

(X) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------