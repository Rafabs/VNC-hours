( ) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------
( ) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------
>> [0008] 18:27 07/01/2025 RB - VNC-HOURS/Área_de_Desenvolvimento/--Historic_Code--/main.py
- [ ] CRIAR BOTÕES PARA EXIBIR HORÁRIOS

de (linha 1)
import os
import logging

# Configuração do sistema de log
logging.basicConfig(filename='log.txt', filemode='a', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def listar_scripts():
    scripts = [f for f in os.listdir() if f.endswith('.py') and f.startswith('VNC_horario_')]
    logging.info(f"Scripts listados: {scripts}")
    return scripts

def executar_script(script):
    logging.info(f"Executando script: {script}")
    os.system(f"python {script}")
    logging.info(f"Script {script} executado com sucesso.")

def main():
    scripts_disponiveis = listar_scripts()

    if not scripts_disponiveis:
        print("Nenhum script disponível para executar.")
        logging.warning("Nenhum script disponível para executar.")
        return

    print("Scripts disponíveis:")
    for i, script in enumerate(scripts_disponiveis, 1):
        print(f"{i}. {script}")

    try:
        escolha = int(input("Escolha o número do script que deseja executar: "))

        if 1 <= escolha <= len(scripts_disponiveis):
            script_escolhido = scripts_disponiveis[escolha - 1]
            executar_script(script_escolhido)
        else:
            print("Escolha inválida.")
            logging.warning("Escolha inválida feita pelo usuário.")
    except ValueError:
        print("Entrada inválida. Por favor, insira um número.")
        logging.error("Entrada inválida - o usuário não digitou um número.")

if __name__ == "__main__":
    main()

para (linha 1)
import os
import csv
import datetime
import customtkinter as ctk
from tkinter import ttk
import logging

# Configuração do sistema de log
logging.basicConfig(filename='log.txt', filemode='a', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Arquivos CSV para cada botão
arquivos_horarios = {
    'DOM_FER': 'VNC_horario_dom_e_fer.csv',
    'SAB': 'VNC_horario_sab.csv',
    'SEG_SEX': 'VNC_horario_seg_sex.csv'
}

class BusScheduleApp:
    def __init__(self, master):
        # Configuração da janela principal
        self.master = master
        master.title('VILA NOVA CACHOEIRINHA')
        master.attributes('-fullscreen', True)
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("dark-blue")

        # Criação do rótulo para exibir os horários
        self.schedule_label = ctk.CTkLabel(
            master, text='', font=ctk.CTkFont(size=50, weight="bold"))
        self.schedule_label.pack(pady=10)

        # Criação do frame da tabela
        self.table_frame = ctk.CTkFrame(master)
        self.table_frame.pack(fill="both", expand=True, padx=20, pady=20)

        style = ttk.Style()
        style.configure("Treeview", font=('Arial', 35), rowheight=80,
                        background="#333333", foreground="#FFFFFF")
        style.configure("Treeview.Heading", font=(
            'Arial', 40, 'bold'), background="#444444")

        # Criação do widget Treeview
        columns = ('PARADA', 'PARTIDA', 'LINHA', 'DESTINO')
        self.treeview = ttk.Treeview(
            self.table_frame, columns=columns, show='headings', height=15)

        for col in columns:
            self.treeview.heading(col, text=col)
            self.treeview.column(col, width=210 if col !=
                                 'DESTINO' else 800, anchor='center' if col != 'DESTINO' else 'w')

        self.treeview.pack(fill="both", expand=True)

        # Criação dos botões dispostos verticalmente
        self.button_frame = ctk.CTkFrame(master)
        self.button_frame.place(x=10, y=10)

        self.buttons = {}
        for label, arquivo in arquivos_horarios.items():
            button = ctk.CTkButton(
                self.button_frame,
                text=label,
                command=lambda l=label, a=arquivo: self.select_schedule(l, a),
                width=10,  # Reduz o tamanho do botão
                height=2,  # Reduz o tamanho do botão
                font=ctk.CTkFont(size=8)  # Ajusta o tamanho da fonte
            )
            button.pack(side="top", pady=2)  # Empilha os botões verticalmente
            self.buttons[label] = button

        # Variáveis de controle
        self.selected_file = list(arquivos_horarios.values())[0]

        # Iniciar atualização
        self.update_schedule()
        self.update_clock()

        # Adiciona o binding para a tecla ESC fechar o programa
        self.master.bind("<Escape>", self.close_program)

    def select_schedule(self, label, arquivo):
        """Ação ao selecionar um arquivo de horários."""
        self.selected_file = arquivo
        self.update_schedule()

        # Registrar log do botão acionado
        logging.info(f"Botão '{label}' acionado. Arquivo carregado: {arquivo}")

    def update_schedule(self):
        """Atualiza a exibição da tabela de horários."""
        try:
            # Ler os horários do arquivo CSV
            with open(self.selected_file, 'r', encoding='utf-8') as csv_file:
                csv_reader = csv.DictReader(csv_file, delimiter=';')
                horarios = [row for row in csv_reader]

            # Hora atual
            hora_atual = datetime.datetime.now().time()

            # Filtrar os horários que ainda vão acontecer
            horarios_filtrados = []
            for h in horarios:
                partida_str = h.get('PARTIDA', '').strip()
                if partida_str:
                    try:
                        partida = datetime.datetime.strptime(
                            partida_str, '%H:%M').time()
                        if partida > hora_atual:
                            horarios_filtrados.append(h)
                    except ValueError:
                        logging.error(f"Erro ao converter horário: {partida_str}")

            # Atualizar a tabela com os horários filtrados
            self.treeview.delete(*self.treeview.get_children())
            for h in horarios_filtrados:
                parada = h.get('PARADA', '-')
                partida = datetime.datetime.strptime(
                    h.get('PARTIDA', '').strip(), '%H:%M').strftime('%H:%M')
                linha = h.get('LINHA', '-')
                destino = h.get('DESTINO', '-')
                self.treeview.insert("", "end", values=(
                    parada, partida, linha, destino))

        except Exception as e:
            logging.error(f"Erro ao atualizar os horários: {e}")

        # Agendar a próxima atualização em 20 segundos
        self.master.after(1000, self.update_schedule)

    def update_clock(self):
        current_time = datetime.datetime.now().strftime('%d/%m/%Y - %H:%M:%S')
        self.schedule_label.configure(
            text=f"VILA NOVA CACHOEIRINHA | {current_time}")
        self.master.after(1000, self.update_clock)

    def close_program(self, event):
        logging.info("Programa finalizado pelo usuário.")
        self.master.destroy()


root = ctk.CTk()
app = BusScheduleApp(root)
root.mainloop()

(X) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------

>> 23:35 04/11/2024 RB - VNC-hours/Área_de_Desenvolvimento/--Historic_Code--/main.py
INCREMENTAR LOG.TXT

de (linha 2)
Vazio

para (linha 2)
import logging

# Configuração do sistema de log
logging.basicConfig(filename='log.txt', filemode='a', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

de (linha 10)
Vazio

para (linha 10)
    logging.info(f"Scripts listados: {scripts}")

de (linha 14)
Vazio

para (linha 14)
    logging.info(f"Executando script: {script}")

de (linha 16)
Vazio

para (linha 16)
    logging.info(f"Script {script} executado com sucesso.")

de (linha 23)
Vazio

para (linha 23)
        logging.warning("Nenhum script disponível para executar.")

de (linha 30)
Vazio

para (linha 30)
    try:
        escolha = int(input("Escolha o número do script que deseja executar: "))

        if 1 <= escolha <= len(scripts_disponiveis):
            script_escolhido = scripts_disponiveis[escolha - 1]
            executar_script(script_escolhido)
        else:
            print("Escolha inválida.")
            logging.warning("Escolha inválida feita pelo usuário.")
    except ValueError:
        print("Entrada inválida. Por favor, insira um número.")
        logging.error("Entrada inválida - o usuário não digitou um número.")
        
(X) SOLUCIONADO
( ) EM DESENVOLVIMENTO
( ) NÃO DEU CERTO
---------------------------------------------------------------------------------------------------------------